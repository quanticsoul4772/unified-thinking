// Package reporting provides benchmark report generation.
package reporting

import (
	"fmt"
	"strings"
	"time"
)

// BenchmarkReport represents a markdown-formatted benchmark report
type BenchmarkReport struct {
	Title     string
	Timestamp time.Time
	GitCommit string
	Suites    []SuiteReport
	Summary   SummaryReport
}

// SuiteReport represents results for one test suite
type SuiteReport struct {
	Name             string
	TotalProblems    int
	CorrectProblems  int
	Accuracy         float64
	ECE              float64
	AvgLatency       time.Duration
	ModeDistribution map[string]int

	// Thompson Sampling RL metrics
	RLEnabled            bool
	StrategyDistribution map[string]int
	StrategySuccessRate  map[string]float64
	InitialAccuracy      float64
	FinalAccuracy        float64
	AccuracyImprovement  float64
	ExplorationRate      float64
	StrategyDiversity    float64
}

// SummaryReport represents overall summary
type SummaryReport struct {
	TotalProblems   int
	TotalCorrect    int
	OverallAccuracy float64
	TotalLatency    time.Duration
}

// GenerateMarkdown creates a markdown report
func GenerateMarkdown(report *BenchmarkReport) string {
	var b strings.Builder

	// Header
	b.WriteString(fmt.Sprintf("# %s\n\n", report.Title))
	b.WriteString(fmt.Sprintf("**Date**: %s\n\n", report.Timestamp.Format("2006-01-02 15:04:05")))
	if report.GitCommit != "" {
		b.WriteString(fmt.Sprintf("**Commit**: `%s`\n\n", report.GitCommit))
	}

	// Summary table
	b.WriteString("## Summary\n\n")
	b.WriteString("| Metric | Value |\n")
	b.WriteString("|--------|-------|\n")
	b.WriteString(fmt.Sprintf("| Total Problems | %d |\n", report.Summary.TotalProblems))
	b.WriteString(fmt.Sprintf("| Correct | %d |\n", report.Summary.TotalCorrect))
	b.WriteString(fmt.Sprintf("| Overall Accuracy | %.2f%% |\n", report.Summary.OverallAccuracy*100))
	b.WriteString(fmt.Sprintf("| Total Time | %v |\n\n", report.Summary.TotalLatency))

	// Per-suite results
	b.WriteString("## Results by Suite\n\n")
	for _, suite := range report.Suites {
		b.WriteString(fmt.Sprintf("### %s\n\n", suite.Name))
		b.WriteString("| Metric | Value |\n")
		b.WriteString("|--------|-------|\n")
		b.WriteString(fmt.Sprintf("| Problems | %d |\n", suite.TotalProblems))
		b.WriteString(fmt.Sprintf("| Correct | %d |\n", suite.CorrectProblems))
		b.WriteString(fmt.Sprintf("| Accuracy | %.2f%% |\n", suite.Accuracy*100))
		b.WriteString(fmt.Sprintf("| ECE (Calibration) | %.4f |\n", suite.ECE))
		b.WriteString(fmt.Sprintf("| Avg Latency | %v |\n", suite.AvgLatency))

		if len(suite.ModeDistribution) > 0 {
			b.WriteString("\n**Mode Distribution:**\n\n")
			for mode, count := range suite.ModeDistribution {
				pct := float64(count) / float64(suite.TotalProblems) * 100
				b.WriteString(fmt.Sprintf("- %s: %d (%.1f%%)\n", mode, count, pct))
			}
		}

		// Thompson Sampling RL metrics
		if suite.RLEnabled {
			b.WriteString("\n**Thompson Sampling RL Metrics:**\n\n")
			b.WriteString("| Metric | Value |\n")
			b.WriteString("|--------|-------|\n")
			b.WriteString(fmt.Sprintf("| Initial Accuracy (first 20%%) | %.2f%% |\n", suite.InitialAccuracy*100))
			b.WriteString(fmt.Sprintf("| Final Accuracy (last 20%%) | %.2f%% |\n", suite.FinalAccuracy*100))

			// Format improvement with +/- indicator
			improvementStr := fmt.Sprintf("%.2f%%", suite.AccuracyImprovement*100)
			if suite.AccuracyImprovement > 0 {
				improvementStr = "+" + improvementStr
			}
			b.WriteString(fmt.Sprintf("| Accuracy Improvement | %s |\n", improvementStr))

			b.WriteString(fmt.Sprintf("| Exploration Rate | %.2f%% |\n", suite.ExplorationRate*100))
			b.WriteString(fmt.Sprintf("| Strategy Diversity (entropy) | %.3f |\n\n", suite.StrategyDiversity))

			if len(suite.StrategyDistribution) > 0 {
				b.WriteString("**Strategy Distribution:**\n\n")
				for strategyID, count := range suite.StrategyDistribution {
					pct := float64(count) / float64(suite.TotalProblems) * 100
					successRate := suite.StrategySuccessRate[strategyID]
					b.WriteString(fmt.Sprintf("- %s: %d (%.1f%%) - Success: %.2f%%\n",
						strategyID, count, pct, successRate*100))
				}
			}
		}

		b.WriteString("\n")
	}

	// Footer
	b.WriteString("---\n\n")
	b.WriteString("*Generated by unified-thinking benchmark framework*\n")

	return b.String()
}

// GenerateASCIIChart creates a simple ASCII chart for trends
func GenerateASCIIChart(title string, data map[int]float64, maxWidth int) string {
	if len(data) == 0 {
		return ""
	}

	var b strings.Builder

	b.WriteString(fmt.Sprintf("%s\n\n", title))

	// Find min/max for scaling
	min, max := 1.0, 0.0
	for _, val := range data {
		if val < min {
			min = val
		}
		if val > max {
			max = val
		}
	}

	// Add some padding
	valueRange := max - min
	if valueRange == 0 {
		valueRange = 1.0
	}

	// Generate chart
	for iter := 1; iter <= len(data); iter++ {
		if val, exists := data[iter]; exists {
			barLength := int(((val - min) / valueRange) * float64(maxWidth))
			if barLength < 0 {
				barLength = 0
			}
			if barLength > maxWidth {
				barLength = maxWidth
			}

			bar := strings.Repeat("â–ˆ", barLength)
			b.WriteString(fmt.Sprintf("Iter %d: %s %.2f%%\n", iter, bar, val*100))
		}
	}

	return b.String()
}
